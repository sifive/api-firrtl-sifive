
def buildDir = mkdir "build/firrtl"

def ivyDepJSON = readIvyDepsJSON here

def firrtlAntlr Unit =
  def outDir = mkdir "{buildDir.getPathName}/antlr"
  def antlrSrcDir = "firrtl/src/main/antlr4"
  def srcs = sources antlrSrcDir `.*\.g4`
  def extractIvyDep json =
    json // `antlr` // `dependencies` | getJString
    | omapPartial stringToIvyDep
    | omapPartial expandJavaIvyDep
    | getOrFail (makeError "antlr dep not found!")
  def ivyDep = ivyDepJSON | rmapPass extractIvyDep
  def package = "firrtl.antlr"
  def main = "org.antlr.v4.Tool"
  def args = "-o", outDir.getPathName, "-visitor", "-no-listener", "-package", package, (map getPathName srcs)
  match ivyDep
    Pass dep = runIvyDep dep main args (outDir, srcs) | getJobOutputs
    Fail err = makeBadPath err, Nil

def firrtlProto Unit =
  def outDir = mkdir "{buildDir.getPathName}/proto"
  def protoSrcDir = "firrtl/src/main/proto"
  def protoSrcs = sources protoSrcDir `.*\.proto`
  def args = "--java_out={outDir.getPathName}", (map getPathName protoSrcs)
  makePlan ("protoc", args) (outDir, protoSrcs)
  | setPlanResources ("google/protobuf/3.5.1", Nil)
  | runJob
  | getJobOutputs

# A `ScalaModule` representing the FIRRTL compiler.
#
# This includes source files generated by Protocol Buffers and ANTLR. The
# resulting set of source files may be compiled as the FIRRTL library, which may
# either be invoked as the standalone compiler program or as a Scala library.
#
# firrtlScalaModule: ScalaModule
global def firrtlScalaModule =
  makeScalaModuleFromJSON here "firrtl"
  | setScalaModuleRootDir "firrtl"
  | setScalaModuleFnGeneratedSources (\_ firrtlProto Unit ++ firrtlAntlr Unit)


global data FirrtlLogLevel =
  FirrtlLogError
  FirrtlLogWarn
  FirrtlLogInfo
  FirrtlLogDebug
  FirrtlLogTrace

def jFirrtlLogLevel = jStringEnum (
  "error" → FirrtlLogError,
  "warn"  → FirrtlLogWarn,
  "info"  → FirrtlLogInfo,
  "debug" → FirrtlLogDebug,
  "trace" → FirrtlLogTrace,
  Nil
)

global data FirrtlCompiler =
  FirrtlCompileHigh
  FirrtlCompileMiddle
  FirrtlCompileLow
  FirrtlCompileVerilog
  FirrtlCompileMVerilog
  FirrtlCompileSVerilog
  FirrtlCompileNone

def jFirrtlCompiler = jStringEnum (
  "high"     → FirrtlCompileHigh,
  "middle"   → FirrtlCompileMiddle,
  "low"      → FirrtlCompileLow,
  "verilog"  → FirrtlCompileVerilog,
  "mverilog" → FirrtlCompileMVerilog,
  "sverilog" → FirrtlCompileSVerilog,
  "none"     → FirrtlCompileNone,
  Nil
)

global data FirrtlInfoMode =
  FirrtlInfoIgnore
  FirrtlInfoUse
  FirrtlInfoGen
  FirrtlInfoAppend

def jFirrtlInfoMode = jStringEnum (
  "ignore" → FirrtlInfoIgnore,
  "use"    → FirrtlInfoUse,
  "gen"    → FirrtlInfoGen,
  "append" → FirrtlInfoAppend,
  Nil
)

# A plan for invoking the FIRRTL compiler on a FIRRTL file.
tuple FirrtlCompilePlan =
  global Jars:             List Path
  global TopName:          String
  global TargetDir:        String
  global LogLevel:         FirrtlLogLevel
  global InputFile:        Path
  global AnnoFiles:        List Path
  global Compiler:         FirrtlCompiler
  global InfoMode:         FirrtlInfoMode
  global CustomTransforms: List String
  global InferRW:          Boolean
  global ReplSeqMem:       List (Pair String String)
  global SplitModules:     Boolean
  global VisibleFiles:     List Path
  global JavaOpts:         List String

def defaultJavaOpts = "-Xmx4G", "-Xss5M", Nil

# Create a FirrtlCompilePlan for specific input files and a specific top.
#
# makeFirrtlCompilePlan:
#   (jars: List Path) => The JAR files for FIRRTL and its dependencies.
#   (topName: String) => The name of the top-level FIRRTL module.
#   (targetDir: String) => Target directory for output files.
#   (inputFile: Path) => Input file describing FIRRTL circuit, either as .fir
#     file or .pb file.
#   FirrtlCompilePlan
global def makeFirrtlCompilePlan jars topName targetDir inputFile =
  FirrtlCompilePlan
  jars                  # Jars
  topName               # TopName
  targetDir             # TargetDir
  FirrtlLogInfo         # LogLevel
  inputFile             # InputFile
  Nil                   # AnnoFiles
  FirrtlCompileVerilog  # Compiler
  FirrtlInfoAppend      # InfoMode
  Nil                   # CustomTransforms
  False                 # InferRW
  Nil                   # ReplSeqMem
  True                  # SplitModules
  Nil                   # VisibleFiles
  defaultJavaOpts       # JavaOpts

def logLevelToString ll = match ll
  FirrtlLogError = "error"
  FirrtlLogWarn  = "warn"
  FirrtlLogInfo  = "info"
  FirrtlLogDebug = "debug"
  FirrtlLogTrace = "trace"

def compilerToString comp = match comp
  FirrtlCompileHigh     = "high"
  FirrtlCompileMiddle   = "middle"
  FirrtlCompileLow      = "low"
  FirrtlCompileVerilog  = "verilog"
  FirrtlCompileMVerilog = "mverilog"
  FirrtlCompileSVerilog = "sverilog"
  FirrtlCompileNone     = "none"

def infoModeToString infoMode = match infoMode
  FirrtlInfoIgnore = "ignore"
  FirrtlInfoUse    = "use"
  FirrtlInfoGen    = "gen"
  FirrtlInfoAppend = "append"

tuple FirrtlCompileOutputs =
  TargetOutputs_: List Path
  AllOutputs_:    List Path
  InputPlan_:     FirrtlCompilePlan

# Get paths for output files in target directory.
#
# getFirrtlCompileOutputsTargetOutputs: FirrtlCompileOutputs => List Path
global def getFirrtlCompileOutputsTargetOutputs = getFirrtlCompileOutputsTargetOutputs_


# Get paths for all output files.
#
# getFirrtlCompileOutputsAllOutputs: FirrtlCompileOutputs => List Path
global def getFirrtlCompileOutputsAllOutputs = getFirrtlCompileOutputsAllOutputs_


# Get original FirrtlCompilePlan used to create these outputs.
#
# getFirrtlCompileOutputsInputPlan: FirrtlCompileOutputs => FirrtlCompilePlan
global def getFirrtlCompileOutputsInputPlan = getFirrtlCompileOutputsInputPlan_

# Run the FIRRTL compiler on a FIRRTL circuit.
#
# runFirrtlCompile: (plan: FirrtlCompilePlan) => FirrtlCompileOutputs
global def runFirrtlCompile plan =
  def jars             = plan.getFirrtlCompilePlanJars
  def topName          = plan.getFirrtlCompilePlanTopName
  def targetDir        = plan.getFirrtlCompilePlanTargetDir
  def logLevel         = plan.getFirrtlCompilePlanLogLevel
  def inputFile        = plan.getFirrtlCompilePlanInputFile
  def annoFiles        = plan.getFirrtlCompilePlanAnnoFiles
  def compiler         = plan.getFirrtlCompilePlanCompiler
  def infoMode         = plan.getFirrtlCompilePlanInfoMode
  def customTransforms = plan.getFirrtlCompilePlanCustomTransforms
  def inferRW          = plan.getFirrtlCompilePlanInferRW
  def replSeqMem       = plan.getFirrtlCompilePlanReplSeqMem
  def splitModules     = plan.getFirrtlCompilePlanSplitModules
  def visibleFiles     = plan.getFirrtlCompilePlanVisibleFiles
  def javaOpts         = plan.getFirrtlCompilePlanJavaOpts

  def main     = "firrtl.Driver"

  def cmdline =
    def withAnnoFiles base = foldr ("-faf", _.getPathName, _) base annoFiles
    def withReplSeqMems base =
      def toCmdline (Pair circuit confFile) cmdline =
        "--repl-seq-mem", "-c:{circuit}:-o:{confFile}", cmdline
      foldr toCmdline base replSeqMem
    def withInferRW base = if inferRW then "--infer-rw", base else base
    def withSplitModules base = if splitModules then "--split-modules", base else base
    def withCustomTransforms base =
      if customTransforms.empty then base
      else "-fct", "{catWith "," customTransforms}", base

    def classpath = jars | map getPathName | catWith ":"
    which "java", javaOpts ++ ("-cp", classpath, main,
    "-tn",            topName,
    "-i",             inputFile.getPathName,
    "-td",            targetDir,
    "-ll",            logLevel.logLevelToString,
    "--info-mode",    infoMode.infoModeToString,
    "--compiler",     compiler.compilerToString,
    Nil
    | withAnnoFiles
    | withCustomTransforms
    | withSplitModules
    | withReplSeqMems
    | withInferRW)

  def inputs = targetDir.mkdir, inputFile, annoFiles ++ jars ++ visibleFiles
  def filterOutputs all =
    # ignore .f files that have absolute paths in them
    filter (!matches `.*\.f` _) all
  def firrtlOutputs =
    makePlan cmdline inputs
    | editPlanFnOutputs (_ _ | filterOutputs)
    | runJob
    | getJobOutputs
  def targetOutputs =
    def regex = regExpCat (targetDir.quote, `/.*`, Nil)
    firrtlOutputs | filter (matches regex _.getPathName)
  FirrtlCompileOutputs targetOutputs firrtlOutputs plan


data Annotations =
  AnnotationsPath Path
  AnnotationsJValue (filename: String) JValue

def jFirrtlAnnotations jPath =
  def base = jOneOf (
    jMap AnnotationsPath jPath,
    jMap2 AnnotationsJValue (jField "filename" jString) (jField "jvalue" jAny),
    Nil
  )
  jOneOf (
    jNestedArrayMap base,
    jMap (_, Nil) base,
    Nil
  )

target writeTarget path contents = write path contents

data Output =
  OutputRegex RegExp
  OutputName String

def getOutput outputs getter =
  def filtered = match getter
    OutputName filename =
      filter (filename.simplify ==~ _.getPathName) outputs
    OutputRegex regex =
      filter (matches regex _.getPathName) outputs
  match filtered
    one, Nil = Pass one
    Nil = match getter
      OutputRegex regex = Fail "firrtl custom output: no file matching `{regExpToString regex}`".makeError
      OutputName filename = Fail "firrtl custom output: no file matching \"{filename}\"".makeError
    many = match getter
      OutputRegex regex = Fail "firrtl custom output: more than one match for `{regExpToString regex}`: {many | map getPathName | catWith ", "}".makeError
      OutputName filename = Fail "firrtl custom output: more than one match for \"{filename}\": {many | map getPathName | catWith ", "}".makeError

data OutputGroup =
  OutputGroupRegex RegExp
  OutputGroupDirectory String RegExp

def getOutputGroup outputs getter = match getter
  OutputGroupDirectory dir subRegex =
    def regex =
      dir
      | simplify
      | quote
      | (_, `/`, subRegex, Nil)
      | regExpCat
    def _ = println regex.format
    filter (matches regex _.getPathName) outputs
  OutputGroupRegex regex =
    filter (matches regex _.getPathName) outputs

data a,, b = a,, b

def stringToRegExpError =
  _
  | stringToRegExp
  | rmapFail (Fail _.makeError)

def jCustomOutputsMap = jObjectMap (jOneOf (
  jMap (_ | OutputName | Pass) jString,
  jMap (_ | stringToRegExpError | rmap OutputRegex) (jField "regex" jString),
  Nil
))

def jCustomOutputGroupsMap = jObjectMap (jOneOf (
  jMap2
  (
    \dir \regexStr
    regexStr
    | getOrElse ".*"
    | stringToRegExpError
    | rmap (OutputGroupDirectory dir)
  )
  (jField "directory" jString)
  (jFieldOption "subRegex" jString),
  jMap (_ | stringToRegExpError | rmap OutputGroupRegex) (jField "regex" jString),
  Nil
))

global def firrtlBuildTarget =
  baseBuildTargetPlan "firrtl"
  | dependsOnFn "classpath" jNestedArrayMap
  | dependsOn "topname" jString
  | dependsOnFn "inputFile" (_)
  | dependsOn "targetDir" jString
  | dependsOnOption "logLevel" jFirrtlLogLevel
  | dependsOnOptionFn "annotations" jFirrtlAnnotations
  | dependsOnOption "compiler" jFirrtlCompiler
  | dependsOnOption "infoMode" jFirrtlInfoMode
  | dependsOnOption "customTransforms" (jNestedArrayMap jString)
  | dependsOnOption "inferRW" jBoolean
  | dependsOnOption "replSeqMem" (jNestedArrayMap (
    jMap2 Pair
    (jField "circuit" jString)
    (jField "confFile" jString)
  ))
  | dependsOnOption "splitModules" jBoolean
  | dependsOnOption "javaOptions" (jNestedArrayMap jString)
  | dependsOnOptionFn "visibleFiles" jNestedArrayMap
  | dependsOnOption "customOutputs" jCustomOutputsMap
  | dependsOnOption "customOutputGroups" jCustomOutputGroupsMap
  | definedAs (
    \classpath
    \topname
    \inputFile
    \targetDir
    \logLevel
    \annotations
    \compiler
    \infoMode
    \customTransforms
    \inferRW
    \rawReplSeqMem
    \splitModules
    \javaOpts
    \visibleFiles
    \customOutputsMap
    \customOutputGroupsMap
    \buildInput (
      def defaultJavaOpts = "-Xmx4G", "-Xss5M", Nil
      def replSeqMem =
        rawReplSeqMem
        | getOrElse Nil
      def annotationsPaths =
        annotations
        | getOrElse Nil
        | map (match _
          AnnotationsPath p = p
          AnnotationsJValue filename jvalue =
            writeTarget "{targetDir}/{filename}".simplify jvalue.prettyJSON
        )
      def firrtlCompile =
        makeFirrtlCompilePlan classpath topname targetDir inputFile
        | setFirrtlCompilePlanLogLevel (getOrElse FirrtlLogInfo logLevel)
        | setFirrtlCompilePlanAnnoFiles annotationsPaths
        | setFirrtlCompilePlanCompiler (getOrElse FirrtlCompileVerilog compiler)
        | setFirrtlCompilePlanInfoMode (getOrElse FirrtlInfoAppend infoMode)
        | setFirrtlCompilePlanCustomTransforms (customTransforms | getOrElse Nil)
        | setFirrtlCompilePlanInferRW (getOrElse False inferRW)
        | setFirrtlCompilePlanReplSeqMem replSeqMem
        | setFirrtlCompilePlanSplitModules (getOrElse False splitModules)
        | setFirrtlCompilePlanJavaOpts (javaOpts | getOrElse defaultJavaOpts)
        | setFirrtlCompilePlanVisibleFiles (visibleFiles | getOrElse Nil)
        | runFirrtlCompile
      def allOutputs = firrtlCompile.getFirrtlCompileOutputsAllOutputs
      def memConfOutputs =
        def fn (Pair name output) =
          output
          | OutputName
          | getOutput allOutputs
          | rmap (_ | bPath | Pair name)
        findFailFn fn replSeqMem
      def rCustomOutputs =
        def fn (Pair name output) =
          output
          | rmapPass (getOutput allOutputs)
          | rmap (_ | bPath | Pair name)
        customOutputsMap
        | getOrElse Nil
        | findFailFn fn
      def rCustomOutputGroups =
        def fn (Pair name outputGroup) =
          outputGroup
          | rmap (
            _
            | getOutputGroup allOutputs
            | map bPath
            | bArray
            | Pair name
          )
        customOutputGroupsMap
        | getOrElse Nil
        | findFailFn fn
      def rFirrtlCompile =
        firrtlCompile
        | getFirrtlCompileOutputsAllOutputs
        | findFailFn getPathResult
        | rmap (\_ firrtlCompile)
      rmapBegin
      | rmapAdd rFirrtlCompile
      | rmapAdd memConfOutputs
      | rmapAdd rCustomOutputs
      | rmapAdd rCustomOutputGroups
      | rmapEnd (_,, _,, _,, _)
    )
  )
  | exports (\(firrtlCompile,, memConfOutputs,, customOutputs,, customOutputGroups) (
    def allOutputs = firrtlCompile.getFirrtlCompileOutputsAllOutputs
    def targetDirOutputs = firrtlCompile.getFirrtlCompileOutputsTargetOutputs
    def verilogOutputs = filter (matches `.*\.v` _.getPathName) allOutputs
    def systemVerilogOutputs = filter (matches `.*\.s?v` _.getPathName) allOutputs
    bObject (
      "targetDirOutputs" → bArray (map bPath targetDirOutputs),
      "systemVerilogOutputs" → bArray (map bPath systemVerilogOutputs),
      "verilogOutputs" → bArray (map bPath verilogOutputs),
      "allOutputs" → bArray (map bPath allOutputs),
      "memConf" → bObject memConfOutputs,
      "customOutputs" → bObject customOutputs,
      "customOutputGroups" → bObject customOutputGroups,
      Nil
    )
  ))
  | makeBuildTarget

publish buildTargets = firrtlBuildTarget, Nil
