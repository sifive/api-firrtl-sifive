
def buildDir = mkdir "build/firrtl"

def ivyDepJSON = readIvyDepsJSON here

def firrtlAntlr Unit =
  def outDir = mkdir "{buildDir.getPathName}/antlr"
  def antlrSrcDir = "firrtl/src/main/antlr4"
  def srcs = sources antlrSrcDir `.*\.g4`
  def extractIvyDep json =
    json // `antlr` // `dependencies` | getJString
    | omapPartial stringToIvyDep
    | omapPartial expandJavaIvyDep
    | getOrFail (makeError "antlr dep not found!")
  def ivyDep = ivyDepJSON | rmapPass extractIvyDep
  def package = "firrtl.antlr"
  def main = "org.antlr.v4.Tool"
  def args = "-o", outDir.getPathName, "-visitor", "-no-listener", "-package", package, (map getPathName srcs)
  match ivyDep
    Pass dep = runIvyDep dep main args (outDir, srcs) | getJobOutputs
    Fail err = makeBadJob err, Nil

global def firrtlProto Unit =
  def outDir = mkdir "{buildDir.getPathName}/proto"
  def protoSrcDir = "firrtl/src/main/proto"
  def protoSrcs = sources protoSrcDir `.*\.proto`
  def args = "--java_out={outDir.getPathName}", (map getPathName protoSrcs)
  makePlan ("protoc", args) (outDir, protoSrcs)
  | setPlanResources ("google/protobuf/3.5.1", Nil)
  | runJob
  | getJobOutputs

global def firrtlScalaModule =
  makeScalaModuleFromJSON here "firrtl"
  | setScalaModuleRootDir "firrtl"
  | setScalaModuleFnGeneratedSources (\_ firrtlProto Unit ++ firrtlAntlr Unit)


global data FirrtlLogLevel =
  FirrtlLogError
  FirrtlLogWarn
  FirrtlLogInfo
  FirrtlLogDebug
  FirrtlLogTrace

global data FirrtlCompiler =
  FirrtlCompileHigh
  FirrtlCompileMiddle
  FirrtlCompileLow
  FirrtlCompileVerilog
  FirrtlCompileMVerilog
  FirrtlCompileSVerilog
  FirrtlCompileNone

global data FirrtlInfoMode =
  FirrtlInfoIgnore
  FirrtlInfoUse
  FirrtlInfoGen
  FirrtlInfoAppend

tuple FirrtlCompilePlan =
  global Jars:             List Path
  global TopName:          String
  global TargetDir:        String
  global LogLevel:         FirrtlLogLevel
  global InputFile:        Path
  global AnnoFiles:        List Path
  global Compiler:         FirrtlCompiler
  global InfoMode:         FirrtlInfoMode
  global CustomTransforms: List String
  global InferRW:          Boolean
  global ReplSeqMem:       List (Pair String String)
  global SplitModules:     Boolean
  global VisibleFiles:     List Path

global def makeFirrtlCompilePlan jars topName targetDir inputFile =
  FirrtlCompilePlan
  jars                  # Jars
  topName               # TopName
  targetDir             # TargetDir
  FirrtlLogInfo         # LogLevel
  inputFile             # InputFile
  Nil                   # AnnoFiles
  FirrtlCompileVerilog  # Compiler
  FirrtlInfoAppend      # InfoMode
  Nil                   # CustomTransforms
  False                 # InferRW
  Nil                   # ReplSeqMem
  True                  # SplitModules
  Nil                   # VisibleFiles

def logLevelToString ll = match ll
  FirrtlLogError = "error"
  FirrtlLogWarn  = "warn"
  FirrtlLogInfo  = "info"
  FirrtlLogDebug = "debug"
  FirrtlLogTrace = "trace"

def compilerToString comp = match comp
  FirrtlCompileHigh     = "high"
  FirrtlCompileMiddle   = "middle"
  FirrtlCompileLow      = "low"
  FirrtlCompileVerilog  = "verilog"
  FirrtlCompileMVerilog = "mverilog"
  FirrtlCompileSVerilog = "sverilog"
  FirrtlCompileNone     = "none"

def infoModeToString infoMode = match infoMode
  FirrtlInfoIgnore = "ignore"
  FirrtlInfoUse    = "use"
  FirrtlInfoGen    = "gen"
  FirrtlInfoAppend = "append"

tuple FirrtlCompileOutputs =
  TargetOutputs_: List Path
  AllOutputs_:    List Path
  InputPlan_:     FirrtlCompilePlan

global def getFirrtlCompileOutputsTargetOutputs = getFirrtlCompileOutputsTargetOutputs_
global def getFirrtlCompileOutputsAllOutputs    = getFirrtlCompileOutputsAllOutputs_
global def getFirrtlCompileOutputsInputPlan     = getFirrtlCompileOutputsInputPlan_

global def runFirrtlCompile plan =
  def jars             = plan.getFirrtlCompilePlanJars
  def topName          = plan.getFirrtlCompilePlanTopName
  def targetDir        = plan.getFirrtlCompilePlanTargetDir
  def logLevel         = plan.getFirrtlCompilePlanLogLevel
  def inputFile        = plan.getFirrtlCompilePlanInputFile
  def annoFiles        = plan.getFirrtlCompilePlanAnnoFiles
  def compiler         = plan.getFirrtlCompilePlanCompiler
  def infoMode         = plan.getFirrtlCompilePlanInfoMode
  def customTransforms = plan.getFirrtlCompilePlanCustomTransforms
  def inferRW          = plan.getFirrtlCompilePlanInferRW
  def replSeqMem       = plan.getFirrtlCompilePlanReplSeqMem
  def splitModules     = plan.getFirrtlCompilePlanSplitModules
  def visibleFiles     = plan.getFirrtlCompilePlanVisibleFiles

  def main     = "firrtl.Driver"

  def cmdline =
    def withAnnoFiles base = foldr ("-faf", _.getPathName, _) base annoFiles
    def withReplSeqMems base =
      def toCmdline (Pair circuit confFile) cmdline =
        "--repl-seq-mem", "-c:{circuit}:-o:{confFile}", cmdline
      foldr toCmdline base replSeqMem
    def withInferRW base = if inferRW then "--infer-rw", base else base
    def withSplitModules base = if splitModules then "--split-modules", base else base
    def withCustomTransforms base =
      if customTransforms.empty then base
      else "-fct", "{catWith "," customTransforms}", base

    def maxHeap = "4G"
    def maxStack = "5M"
    def classpath = jars | map getPathName | catWith ":"
    which "java",  "-Xmx{maxHeap}", "-Xss{maxStack}", "-cp", classpath, main,
    "-tn",            topName,
    "-i",             inputFile.getPathName,
    "-td",            targetDir,
    "-ll",            logLevel.logLevelToString,
    "--info-mode",    infoMode.infoModeToString,
    "--compiler",     compiler.compilerToString,
    Nil
    | withAnnoFiles
    | withReplSeqMems
    | withInferRW
    | withSplitModules
    | withCustomTransforms

  def inputs = targetDir.mkdir, inputFile, annoFiles ++ jars ++ visibleFiles
  def filterOutputs all =
    # ignore .f files that have absolute paths in them
    filter (!matches `.*\.f` _) all
  def firrtlOutputs =
    makePlan cmdline inputs
    | editPlanFnOutputs (_ _ | filterOutputs)
    | runJob
    | getJobOutputs
  def targetOutputs =
    def regex = regExpCat (targetDir.quote, `/.*`, Nil)
    firrtlOutputs | filter (matches regex _.getPathName)
  FirrtlCompileOutputs targetOutputs firrtlOutputs plan
