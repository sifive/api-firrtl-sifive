
def buildDir = mkdir "build/firrtl"

def ivyDepJSON = readIvyDepsJSON here

def firrtlRoot = findGitRepositoryWithFallback "firrtl"

def firrtlAntlr Unit =
  def outDir = mkdir "{buildDir.getPathName}/antlr"
  def antlrSrcDir = "{firrtlRoot}/src/main/antlr4"
  def srcs = sources antlrSrcDir `.*\.g4`
  def extractIvyDep json =
    json // `antlr` // `dependencies` | getJString
    | omapPartial stringToIvyDep
    | omapPartial expandJavaIvyDep
    | getOrFail (makeError "antlr dep not found!")
  def ivyDep = ivyDepJSON | rmapPass extractIvyDep
  def _package = "firrtl.antlr"
  def main = "org.antlr.v4.Tool"
  def args = "-o", outDir.getPathName, "-visitor", "-no-listener", "-package", _package, (map getPathName srcs)
  match ivyDep
    Pass dep = runIvyDep dep main args (outDir, srcs) | getJobOutputs
    Fail err = makeBadPath err, Nil

def firrtlProto Unit =
  def outDir = mkdir "{buildDir.getPathName}/proto"
  def protoSrcDir = "{firrtlRoot}/src/main/proto"
  def protoSrcs = sources protoSrcDir `.*\.proto`
  def args = "--java_out={outDir.getPathName}", (map getPathName protoSrcs)
  makePlan ("protoc", args) (outDir, protoSrcs)
  | setPlanResources ("google/protobuf/3.5.1", Nil)
  | runJob
  | getJobOutputs

# A `ScalaModule` representing the FIRRTL compiler.
#
# This includes source files generated by Protocol Buffers and ANTLR. The
# resulting set of source files may be compiled as the FIRRTL library, which may
# either be invoked as the standalone compiler program or as a Scala library.
#
# firrtlScalaModule: ScalaModule
global def firrtlScalaModule =
  makeScalaModuleFromJSON here "firrtl"
  | setScalaModuleRootDir firrtlRoot
  | setScalaModuleFnGeneratedSources (\_ firrtlProto Unit ++ firrtlAntlr Unit)


global data FirrtlLogLevel =
  FirrtlLogError
  FirrtlLogWarn
  FirrtlLogInfo
  FirrtlLogDebug
  FirrtlLogTrace

global data FirrtlCompiler =
  FirrtlCompileHigh
  FirrtlCompileMiddle
  FirrtlCompileLow
  FirrtlCompileVerilog
  FirrtlCompileMVerilog
  FirrtlCompileSVerilog
  FirrtlCompileNone

global data FirrtlInfoMode =
  FirrtlInfoIgnore
  FirrtlInfoUse
  FirrtlInfoGen
  FirrtlInfoAppend

# A plan for invoking the FIRRTL compiler on a FIRRTL file.
tuple FirrtlCompilePlan =
  global Jars:             List Path
  global TopName:          String
  global TargetDir:        String
  global LogLevel:         FirrtlLogLevel
  global InputFile:        Path
  global AnnoFiles:        List Path
  global Compiler:         FirrtlCompiler
  global InfoMode:         FirrtlInfoMode
  global CustomTransforms: List String
  global InferRW:          Boolean
  global ReplSeqMem:       List (Pair String String)
  global SplitModules:     Boolean
  global VisibleFiles:     List Path
  global JavaOpts:         List String

def defaultJavaOpts = "-Xmx4G", "-Xss5M", Nil

# Create a FirrtlCompilePlan for specific input files and a specific top.
#
# makeFirrtlCompilePlan:
#   (jars: List Path) => The JAR files for FIRRTL and its dependencies.
#   (topName: String) => The name of the top-level FIRRTL module.
#   (targetDir: String) => Target directory for output files.
#   (inputFile: Path) => Input file describing FIRRTL circuit, either as .fir
#     file or .pb file.
#   FirrtlCompilePlan
global def makeFirrtlCompilePlan jars topName targetDir inputFile =
  FirrtlCompilePlan
  jars                  # Jars
  topName               # TopName
  targetDir             # TargetDir
  FirrtlLogInfo         # LogLevel
  inputFile             # InputFile
  Nil                   # AnnoFiles
  FirrtlCompileVerilog  # Compiler
  FirrtlInfoAppend      # InfoMode
  Nil                   # CustomTransforms
  False                 # InferRW
  Nil                   # ReplSeqMem
  True                  # SplitModules
  Nil                   # VisibleFiles
  defaultJavaOpts       # JavaOpts

def logLevelToString ll = match ll
  FirrtlLogError = "error"
  FirrtlLogWarn  = "warn"
  FirrtlLogInfo  = "info"
  FirrtlLogDebug = "debug"
  FirrtlLogTrace = "trace"

def compilerToString comp = match comp
  FirrtlCompileHigh     = "high"
  FirrtlCompileMiddle   = "middle"
  FirrtlCompileLow      = "low"
  FirrtlCompileVerilog  = "verilog"
  FirrtlCompileMVerilog = "mverilog"
  FirrtlCompileSVerilog = "sverilog"
  FirrtlCompileNone     = "none"

def infoModeToString infoMode = match infoMode
  FirrtlInfoIgnore = "ignore"
  FirrtlInfoUse    = "use"
  FirrtlInfoGen    = "gen"
  FirrtlInfoAppend = "append"

tuple FirrtlCompileOutputs =
  TargetOutputs_: List Path
  AllOutputs_:    List Path
  InputPlan_:     FirrtlCompilePlan
  # Only exists for this to be simultaaneously compatible with Wake 0.17 and
  # 0.18 by forcing this tuple to be globally visible.
  global Wake0_18_Shim_: Unit

# Get paths for output files in target directory.
#
# getFirrtlCompileOutputsTargetOutputs: FirrtlCompileOutputs => List Path
global def getFirrtlCompileOutputsTargetOutputs = getFirrtlCompileOutputsTargetOutputs_


# Get paths for all output files.
#
# getFirrtlCompileOutputsAllOutputs: FirrtlCompileOutputs => List Path
global def getFirrtlCompileOutputsAllOutputs = getFirrtlCompileOutputsAllOutputs_


# Get original FirrtlCompilePlan used to create these outputs.
#
# getFirrtlCompileOutputsInputPlan: FirrtlCompileOutputs => FirrtlCompilePlan
global def getFirrtlCompileOutputsInputPlan = getFirrtlCompileOutputsInputPlan_

# Run the FIRRTL compiler on a FIRRTL circuit.
#
# runFirrtlCompile: (plan: FirrtlCompilePlan) => FirrtlCompileOutputs
global def runFirrtlCompile plan =
  def jars             = plan.getFirrtlCompilePlanJars
  def topName          = plan.getFirrtlCompilePlanTopName
  def targetDir        = plan.getFirrtlCompilePlanTargetDir
  def logLevel         = plan.getFirrtlCompilePlanLogLevel
  def inputFile        = plan.getFirrtlCompilePlanInputFile
  def annoFiles        = plan.getFirrtlCompilePlanAnnoFiles
  def compiler         = plan.getFirrtlCompilePlanCompiler
  def infoMode         = plan.getFirrtlCompilePlanInfoMode
  def customTransforms = plan.getFirrtlCompilePlanCustomTransforms
  def inferRW          = plan.getFirrtlCompilePlanInferRW
  def replSeqMem       = plan.getFirrtlCompilePlanReplSeqMem
  def splitModules     = plan.getFirrtlCompilePlanSplitModules
  def visibleFiles     = plan.getFirrtlCompilePlanVisibleFiles
  def javaOpts         = plan.getFirrtlCompilePlanJavaOpts

  def main     = "firrtl.Driver"

  def cmdline =
    def withAnnoFiles base = foldr ("-faf", _.getPathName, _) base annoFiles
    def withReplSeqMems base =
      def toCmdline (Pair circuit confFile) cmdline =
        "--repl-seq-mem", "-c:{circuit}:-o:{confFile}", cmdline
      foldr toCmdline base replSeqMem
    def withInferRW base = if inferRW then "--infer-rw", base else base
    def withSplitModules base = if splitModules then "--split-modules", base else base
    def withCustomTransforms base =
      if customTransforms.empty then base
      else "-fct", "{catWith "," customTransforms}", base

    def classpath = jars | map getPathName | catWith ":"
    "java", javaOpts ++ ("-cp", classpath, main,
    "-tn",            topName,
    "-i",             inputFile.getPathName,
    "-td",            targetDir,
    "-ll",            logLevel.logLevelToString,
    "--info-mode",    infoMode.infoModeToString,
    "--compiler",     compiler.compilerToString,
    Nil
    | withAnnoFiles
    | withCustomTransforms
    | withSplitModules
    | withReplSeqMems
    | withInferRW)

  def inputs = targetDir.mkdir, inputFile, annoFiles ++ jars ++ visibleFiles
  def filterOutputs all =
    # ignore .f files that have absolute paths in them
    filter (!matches `.*\.f` _) all
  def firrtlOutputs =
    makePlan cmdline inputs
    | setPlanResources ("openjdk/java/1.8.0", Nil)
    | editPlanFnOutputs (_ _ | filterOutputs)
    | runJob
    | getJobOutputs
  def targetOutputs =
    def regex = regExpCat (targetDir.quote, `/.*`, Nil)
    firrtlOutputs | filter (matches regex _.getPathName)
  FirrtlCompileOutputs targetOutputs firrtlOutputs plan Unit
