
def buildDir = mkdir "build/firrtl"

def ivyDepJSON = readIvyDepsJSON here

def firrtlAntlr Unit =
  def outDir = mkdir "{buildDir.getPathName}/antlr"
  def antlrSrcDir = "firrtl/src/main/antlr4"
  def srcs = sources antlrSrcDir `.*\.g4`
  def extractIvyDep json =
    json // `antlr` // `dependencies` | getJString
    | omapPartial stringToIvyDep
    | omapPartial expandJavaIvyDep
    | getOrFail (makeError "antlr dep not found!")
  def ivyDep = ivyDepJSON | rmapPass extractIvyDep
  def package = "firrtl.antlr"
  def main = "org.antlr.v4.Tool"
  def args = "-o", outDir.getPathName, "-visitor", "-no-listener", "-package", package, (map getPathName srcs)
  match ivyDep
    Pass dep = runIvyDep dep main args (outDir, srcs) | getJobOutputs
    Fail err = makeBadPath err, Nil

def firrtlProto Unit =
  def outDir = mkdir "{buildDir.getPathName}/proto"
  def protoSrcDir = "firrtl/src/main/proto"
  def protoSrcs = sources protoSrcDir `.*\.proto`
  def args = "--java_out={outDir.getPathName}", (map getPathName protoSrcs)
  makePlan ("protoc", args) (outDir, protoSrcs)
  | setPlanResources ("google/protobuf/3.5.1", Nil)
  | runJob
  | getJobOutputs

# A `ScalaModule` representing the FIRRTL compiler.
#
# This includes source files generated by Protocol Buffers and ANTLR. The
# resulting set of source files may be compiled as the FIRRTL library, which may
# either be invoked as the standalone compiler program or as a Scala library.
#
# firrtlScalaModule: ScalaModule
global def firrtlScalaModule =
  makeScalaModuleFromJSON here "firrtl"
  | setScalaModuleRootDir "firrtl"
  | setScalaModuleFnGeneratedSources (\_ firrtlProto Unit ++ firrtlAntlr Unit)


global data FirrtlLogLevel =
  FirrtlLogError
  FirrtlLogWarn
  FirrtlLogInfo
  FirrtlLogDebug
  FirrtlLogTrace

def jFirrtlLogLevel = jStringEnum (
  "error" → FirrtlLogError,
  "warn"  → FirrtlLogWarn,
  "info"  → FirrtlLogInfo,
  "debug" → FirrtlLogDebug,
  "trace" → FirrtlLogTrace,
  Nil
)

global data FirrtlCompiler =
  FirrtlCompileHigh
  FirrtlCompileMiddle
  FirrtlCompileLow
  FirrtlCompileVerilog
  FirrtlCompileMVerilog
  FirrtlCompileSVerilog
  FirrtlCompileNone

def jFirrtlCompiler = jStringEnum (
  "high"     → FirrtlCompileHigh,
  "middle"   → FirrtlCompileMiddle,
  "low"      → FirrtlCompileLow,
  "verilog"  → FirrtlCompileVerilog,
  "mverilog" → FirrtlCompileMVerilog,
  "sverilog" → FirrtlCompileSVerilog,
  "none"     → FirrtlCompileNone,
  Nil
)

global data FirrtlInfoMode =
  FirrtlInfoIgnore
  FirrtlInfoUse
  FirrtlInfoGen
  FirrtlInfoAppend

def jFirrtlInfoMode = jStringEnum (
  "ignore" → FirrtlInfoIgnore,
  "use"    → FirrtlInfoUse,
  "gen"    → FirrtlInfoGen,
  "append" → FirrtlInfoAppend,
  Nil
)

# A plan for invoking the FIRRTL compiler on a FIRRTL file.
tuple FirrtlCompilePlan =
  global Jars:             List Path
  global TopName:          String
  global TargetDir:        String
  global LogLevel:         FirrtlLogLevel
  global InputFile:        Path
  global AnnoFiles:        List Path
  global Compiler:         FirrtlCompiler
  global InfoMode:         FirrtlInfoMode
  global CustomTransforms: List String
  global InferRW:          Boolean
  global ReplSeqMem:       List (Pair String String)
  global SplitModules:     Boolean
  global VisibleFiles:     List Path
  global JavaOpts:         List String

def defaultJavaOpts = "-Xmx4G", "-Xss5M", Nil

# Create a FirrtlCompilePlan for specific input files and a specific top.
#
# makeFirrtlCompilePlan:
#   (jars: List Path) => The JAR files for FIRRTL and its dependencies.
#   (topName: String) => The name of the top-level FIRRTL module.
#   (targetDir: String) => Target directory for output files.
#   (inputFile: Path) => Input file describing FIRRTL circuit, either as .fir
#     file or .pb file.
#   FirrtlCompilePlan
global def makeFirrtlCompilePlan jars topName targetDir inputFile =
  FirrtlCompilePlan
  jars                  # Jars
  topName               # TopName
  targetDir             # TargetDir
  FirrtlLogInfo         # LogLevel
  inputFile             # InputFile
  Nil                   # AnnoFiles
  FirrtlCompileVerilog  # Compiler
  FirrtlInfoAppend      # InfoMode
  Nil                   # CustomTransforms
  False                 # InferRW
  Nil                   # ReplSeqMem
  True                  # SplitModules
  Nil                   # VisibleFiles
  defaultJavaOpts       # JavaOpts

def logLevelToString ll = match ll
  FirrtlLogError = "error"
  FirrtlLogWarn  = "warn"
  FirrtlLogInfo  = "info"
  FirrtlLogDebug = "debug"
  FirrtlLogTrace = "trace"

def compilerToString comp = match comp
  FirrtlCompileHigh     = "high"
  FirrtlCompileMiddle   = "middle"
  FirrtlCompileLow      = "low"
  FirrtlCompileVerilog  = "verilog"
  FirrtlCompileMVerilog = "mverilog"
  FirrtlCompileSVerilog = "sverilog"
  FirrtlCompileNone     = "none"

def infoModeToString infoMode = match infoMode
  FirrtlInfoIgnore = "ignore"
  FirrtlInfoUse    = "use"
  FirrtlInfoGen    = "gen"
  FirrtlInfoAppend = "append"

tuple FirrtlCompileOutputs =
  TargetOutputs_: List Path
  AllOutputs_:    List Path
  InputPlan_:     FirrtlCompilePlan

# Get paths for output files in target directory.
#
# getFirrtlCompileOutputsTargetOutputs: FirrtlCompileOutputs => List Path
global def getFirrtlCompileOutputsTargetOutputs = getFirrtlCompileOutputsTargetOutputs_


# Get paths for all output files.
#
# getFirrtlCompileOutputsAllOutputs: FirrtlCompileOutputs => List Path
global def getFirrtlCompileOutputsAllOutputs = getFirrtlCompileOutputsAllOutputs_


# Get original FirrtlCompilePlan used to create these outputs.
#
# getFirrtlCompileOutputsInputPlan: FirrtlCompileOutputs => FirrtlCompilePlan
global def getFirrtlCompileOutputsInputPlan = getFirrtlCompileOutputsInputPlan_

# Run the FIRRTL compiler on a FIRRTL circuit.
#
# runFirrtlCompile: (plan: FirrtlCompilePlan) => FirrtlCompileOutputs
global def runFirrtlCompile plan =
  def jars             = plan.getFirrtlCompilePlanJars
  def topName          = plan.getFirrtlCompilePlanTopName
  def targetDir        = plan.getFirrtlCompilePlanTargetDir
  def logLevel         = plan.getFirrtlCompilePlanLogLevel
  def inputFile        = plan.getFirrtlCompilePlanInputFile
  def annoFiles        = plan.getFirrtlCompilePlanAnnoFiles
  def compiler         = plan.getFirrtlCompilePlanCompiler
  def infoMode         = plan.getFirrtlCompilePlanInfoMode
  def customTransforms = plan.getFirrtlCompilePlanCustomTransforms
  def inferRW          = plan.getFirrtlCompilePlanInferRW
  def replSeqMem       = plan.getFirrtlCompilePlanReplSeqMem
  def splitModules     = plan.getFirrtlCompilePlanSplitModules
  def visibleFiles     = plan.getFirrtlCompilePlanVisibleFiles
  def javaOpts         = plan.getFirrtlCompilePlanJavaOpts

  def main     = "firrtl.Driver"

  def cmdline =
    def withAnnoFiles base = foldr ("-faf", _.getPathName, _) base annoFiles
    def withReplSeqMems base =
      def toCmdline (Pair circuit confFile) cmdline =
        "--repl-seq-mem", "-c:{circuit}:-o:{confFile}", cmdline
      foldr toCmdline base replSeqMem
    def withInferRW base = if inferRW then "--infer-rw", base else base
    def withSplitModules base = if splitModules then "--split-modules", base else base
    def withCustomTransforms base =
      if customTransforms.empty then base
      else "-fct", "{catWith "," customTransforms}", base

    def classpath = jars | map getPathName | catWith ":"
    which "java", javaOpts ++ ("-cp", classpath, main,
    "-tn",            topName,
    "-i",             inputFile.getPathName,
    "-td",            targetDir,
    "-ll",            logLevel.logLevelToString,
    "--info-mode",    infoMode.infoModeToString,
    "--compiler",     compiler.compilerToString,
    Nil
    | withAnnoFiles
    | withCustomTransforms
    | withSplitModules
    | withReplSeqMems
    | withInferRW)

  def inputs = targetDir.mkdir, inputFile, annoFiles ++ jars ++ visibleFiles
  def filterOutputs all =
    # ignore .f files that have absolute paths in them
    filter (!matches `.*\.f` _) all
  def firrtlOutputs =
    makePlan cmdline inputs
    | editPlanFnOutputs (_ _ | filterOutputs)
    | runJob
    | getJobOutputs
  def targetOutputs =
    def regex = regExpCat (targetDir.quote, `/.*`, Nil)
    firrtlOutputs | filter (matches regex _.getPathName)
  FirrtlCompileOutputs targetOutputs firrtlOutputs plan


data Annotations =
  AnnotationsPath Path
  AnnotationsJValue (filename: String) JValue

def jFirrtlAnnotations jPath =
  def base = jOneOf (
    jMap AnnotationsPath jPath,
    jMap2 AnnotationsJValue (jField "filename" jString) (jField "jvalue" jAny),
    Nil
  )
  jOneOf (
    jNestedArrayMap base,
    jMap (_, Nil) base,
    Nil
  )

target writeTarget path contents = write path contents

global def firrtlBuildTarget =
  baseBuildTargetPlan "firrtl"
  | dependsOnFn "classpath" jNestedArrayMap
  | dependsOn "topname" jString
  | dependsOnFn "inputFile" (_)
  | dependsOnOption "logLevel" jFirrtlLogLevel
  | dependsOnOptionFn "annotations" jFirrtlAnnotations
  | dependsOnOption "compiler" jFirrtlCompiler
  | dependsOnOption "infoMode" jFirrtlInfoMode
  | dependsOnOption "customTransforms" (jNestedArrayMap jString)
  | dependsOnOption "inferRW" jBoolean
  | dependsOnOption "replSeqMem" (jNestedArrayMap (
    jMap2 Pair
    (jField "circuit" jString)
    (jField "confFile" jString)
  ))
  | dependsOnOption "splitModules" jBoolean
  | dependsOnOption "javaOptions" (jNestedArrayMap jString)
  | dependsOnOptionFn "visibleFiles" jNestedArrayMap
  | definedAs (
    \classpath
    \topname
    \inputFile
    \logLevel
    \annotations
    \compiler
    \infoMode
    \customTransforms
    \inferRW
    \rawReplSeqMem
    \splitModules
    \javaOpts
    \visibleFiles
    \buildInput

    match buildInput.getBuildTargetInputsOutputDir
      None = Fail "no target directory specified".makeError
      Some targetDir =
        def defaultJavaOpts = "-Xmx4G", "-Xss5M", Nil
        def toTargetDirFile file = "{targetDir}/{file}".simplify
        def replSeqMem =
          rawReplSeqMem
          | getOrElse Nil
          | map (editPairSecond toTargetDirFile)
        def annotationsPaths =
          annotations
          | getOrElse Nil
          | map (match _
            AnnotationsPath p = p
            AnnotationsJValue filename jvalue =
              writeTarget "{targetDir}/{filename}".simplify jvalue.prettyJSON
          )
        def firrtlCompile =
          makeFirrtlCompilePlan classpath topname targetDir inputFile
          | setFirrtlCompilePlanLogLevel (getOrElse FirrtlLogInfo logLevel)
          | setFirrtlCompilePlanAnnoFiles annotationsPaths
          | setFirrtlCompilePlanCompiler (getOrElse FirrtlCompileVerilog compiler)
          | setFirrtlCompilePlanInfoMode (getOrElse FirrtlInfoAppend infoMode)
          | setFirrtlCompilePlanCustomTransforms (customTransforms | getOrElse Nil)
          | setFirrtlCompilePlanInferRW (getOrElse False inferRW)
          | setFirrtlCompilePlanReplSeqMem replSeqMem
          | setFirrtlCompilePlanSplitModules (getOrElse False splitModules)
          | setFirrtlCompilePlanJavaOpts (javaOpts | getOrElse defaultJavaOpts)
          | setFirrtlCompilePlanVisibleFiles (visibleFiles | getOrElse Nil)
          | runFirrtlCompile
        def findFile (Pair _ rawFilename) =
          def filename = rawFilename.toTargetDirFile
          firrtlCompile
          | getFirrtlCompileOutputsAllOutputs
          | find (_.getPathName ==* filename)
          | omap (rawFilename → _.getPairFirst)
        def memConfOutputs =
          rawReplSeqMem
          | getOrElse Nil
          | mapPartial findFile
        firrtlCompile
        | getFirrtlCompileOutputsAllOutputs
        | findFailFn getPathResult
        | rmap (\_ firrtlCompile → memConfOutputs)
  )
  | exports (\(Pair firrtlCompile memConfOutputs) (
    def allOutputs = firrtlCompile.getFirrtlCompileOutputsAllOutputs
    def targetDirOutputs = firrtlCompile.getFirrtlCompileOutputsTargetOutputs
    def verilogOutputs = filter (matches `.*\.v` _.getPathName) allOutputs
    def systemVerilogOutputs = filter (matches `.*\.s?v` _.getPathName) allOutputs
    bObject (
      "targetDirOutputs" → bArray (map bPath targetDirOutputs),
      "systemVerilogOutputs" → bArray (map bPath systemVerilogOutputs),
      "verilogOutputs" → bArray (map bPath verilogOutputs),
      "allOutputs" → bArray (map bPath allOutputs),
      "memConf" → bObject (
        map (\(Pair name path) name → bPath path) memConfOutputs
      ),
      Nil
    )
  ))
  | makeBuildTarget
